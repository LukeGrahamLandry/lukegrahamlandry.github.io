<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Modding Tutorial </title>

    <link rel="shortcut icon" href="/img/logo.png">
    <link rel="stylesheet" href="/styles/tutorial.css">
    <link rel="stylesheet" href="/styles/md.css">
    <link rel="stylesheet" href="/styles/index.css">
    <link rel="stylesheet" id="theme" href="">
    <link rel="stylesheet" href="/code.css">

    <style>
        #nav {
            width: 90%;
            opacity: 60%;
        }

        #nav:hover {
            opacity: 100%;
        }

        #nav .post {
            width: 30%;
            display: inline-block;
            text-decoration: none;
        }

        .centered {
            width: 100%; max-width: 800px; display: inline-block;
        }

        @media only screen and (max-width: 850px) {
            #nav .post {
                width: 45%;
            }
        }

        @media only screen and (max-width: 600px) {
            #nav {
                width: 95%;
                max-width: 300px;
            }

            #nav .post {
                width: auto;
                max-width: 300px;
                display: block;
            }
        }
    </style>
    
</head>
<body>
        <div class="hide-for-print centered" style="text-align: left;">
            <a href="/" style="font-size: 2rem;">Home</a> 
            <label class="switch" style="float: right;">
                <input type="checkbox" id="dark" onclick="updateDarkmode()">
                <span class="slider round"></span>
            </label>
        </div> <br> <br>

        <div id="content" class="markdown-body centered">
            <p>Make a tile entity that kills nearby mobs.  </p>
<p>A tile entity is a simplified version of an entity that is bound to a specific block the the world. It knows its position, can react to ticks and saves data when the world is reloaded. Some vanilla examples are chests, furnaces and beacons. </p>
<h2>Init</h2>
<p>Start by making a block for your tile entity. It will have its own class just like we made for other advanced blocks in the last tutorial. </p>
<pre><code class="highlight"><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">RegistryObject</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">&gt;</span> <span class="n">MOB_SLAYER</span> <span class="o">=</span> <span class="n">BLOCKS</span><span class="p">.</span><span class="na">register</span><span class="p">(</span><span class="s">&quot;mob_slayer&quot;</span><span class="p">,</span>
            <span class="p">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">MobSlayerBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">.</span><span class="na">Properties</span><span class="p">.</span><span class="na">copy</span><span class="p">(</span><span class="n">Blocks</span><span class="p">.</span><span class="na">IRON_BLOCK</span><span class="p">)));</span>
</pre></code></pre>
<p>Then you will need to register your tile entity. Make a new class called <code class="highlight"><span></span><span class="n">TileEntityInit</span>
</pre></code>. We will start by getting a deferred register just like for blocks and items. </p>
<pre><code class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TileEntityInit</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">DeferredRegister</span><span class="o">&lt;</span><span class="n">TileEntityType</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">TILE_ENTITY_TYPES</span> <span class="o">=</span> <span class="n">DeferredRegister</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">ForgeRegistries</span><span class="p">.</span><span class="na">TILE_ENTITIES</span><span class="p">,</span> <span class="n">FirstModMain</span><span class="p">.</span><span class="na">MOD_ID</span><span class="p">);</span>
<span class="p">}</span>
</pre></code></pre>
<p>Then register your tile entity. The string you pass in is the registry name which can be anything you want (all lower case, no weird characters as usual). Then you need a supplier for a <code class="highlight"><span></span><span class="n">TileEntityType</span>
</pre></code> which has a builder to use. The builder takes a supplier to make new instance of your tile entity. For this, use a method reference to the constructor of your tile entity class (we'll make this class in the next step). Then you need to tell it the types of blocks that your tile entity is allowed to be bound to. I'll just have one (the block we made earlier) but you can have multiple, just separate them with commas. Then we call the <code class="highlight"><span></span><span class="n">build</span>
</pre></code> method of the builder to get the type. </p>
<pre><code class="highlight"><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">RegistryObject</span><span class="o">&lt;</span><span class="n">TileEntityType</span><span class="o">&lt;</span><span class="n">MobSlayerTile</span><span class="o">&gt;&gt;</span> <span class="n">MOB_SLAYER</span> <span class="o">=</span> <span class="n">TILE_ENTITY_TYPES</span><span class="p">.</span><span class="na">register</span><span class="p">(</span><span class="s">&quot;mob_slayer&quot;</span><span class="p">,</span>
            <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">TileEntityType</span><span class="p">.</span><span class="na">Builder</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">MobSlayerTile</span><span class="p">::</span><span class="k">new</span><span class="p">,</span> <span class="n">BlockInit</span><span class="p">.</span><span class="na">MOB_SLAYER</span><span class="p">.</span><span class="na">get</span><span class="p">()).</span><span class="na">build</span><span class="p">(</span><span class="kc">null</span><span class="p">));</span>
</pre></code></pre>
<p>The null argument passed to the build method is a "data fixer type". Honestly, I have no idea what that means. It seems to not be used for anything and leaving it null has always worked for me. If you happen to know what it does, please let me know, I'm curious. </p>
<p>Like with the item and block registries, you have to tell minecraft that you're trying to register things. Add this line to the constructor of your main class:</p>
<pre><code class="highlight"><span></span><span class="n">TileEntityInit</span><span class="p">.</span><span class="na">TILE_ENTITY_TYPES</span><span class="p">.</span><span class="na">register</span><span class="p">(</span><span class="n">modEventBus</span><span class="p">);</span>
</pre></code></pre>
<h2>Block Class</h2>
<p>There are two methods you need to override on your block to add your tile entity. <code class="highlight"><span></span><span class="n">hasTileEntity</span>
</pre></code> should simply return true and <code class="highlight"><span></span><span class="n">createTileEntity</span>
</pre></code> should return a new instance of your tile entity. I'm using the tile entity type's <code class="highlight"><span></span><span class="n">create</span>
</pre></code> method but you could directly call the constructor once you make your tile entity class).</p>
<pre><code class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MobSlayerBlock</span> <span class="kd">extends</span> <span class="n">Block</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">MobSlayerBlock</span><span class="p">(</span><span class="n">AbstractBlock</span><span class="p">.</span><span class="na">Properties</span> <span class="n">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">super</span><span class="p">(</span><span class="n">props</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasTileEntity</span><span class="p">(</span><span class="n">BlockState</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">TileEntity</span> <span class="nf">createTileEntity</span><span class="p">(</span><span class="n">BlockState</span> <span class="n">state</span><span class="p">,</span> <span class="n">IBlockReader</span> <span class="n">world</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">TileEntityInit</span><span class="p">.</span><span class="na">MOB_SLAYER</span><span class="p">.</span><span class="na">get</span><span class="p">().</span><span class="na">create</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></code></pre>
<h2>Tile Class</h2>
<p>Now create the tile entity class you referenced earlier (make a new <code class="highlight"><span></span><span class="n">tile</span>
</pre></code> package to keep organized). As you may have guessed, the class will extend <code class="highlight"><span></span><span class="n">TileEntity</span>
</pre></code>. Pass your tile entity type to the super constructor. </p>
<pre><code class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MobSlayerTile</span> <span class="kd">extends</span> <span class="n">TileEntity</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">MobSlayerTile</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">super</span><span class="p">(</span><span class="n">TileEntityInit</span><span class="p">.</span><span class="na">MOB_SLAYER</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></code></pre>
<h3>Tick</h3>
<p>To react to ticks, your tile entity must implement <code class="highlight"><span></span><span class="n">ITickableTileEntity</span>
</pre></code>. The <code class="highlight"><span></span><span class="n">tick</span>
</pre></code> method will be called every tick. </p>
<pre><code class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MobSlayerTile</span> <span class="kd">extends</span> <span class="n">TileEntity</span> <span class="kd">implements</span> <span class="n">ITickableTileEntity</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">MobSlayerTile</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">super</span><span class="p">(</span><span class="n">TileEntityInit</span><span class="p">.</span><span class="na">MOB_SLAYER</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">tick</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// do stuff here</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></code></pre>
<p>You can do anything you want here but I want my tile entity to kill nearby monsters. I'll start by writing some logic for when to hurt the mobs. </p>
<p>I'll need a <code class="highlight"><span></span><span class="n">timer</span>
</pre></code> field (because I don't want to deal damage every tick, that would be too op) and an <code class="highlight"><span></span><span class="n">isActive</span>
</pre></code> field (because I want the player to be able to turn it off sometimes). So I'll check that we're on the server side (because that's where logic like dealing damage should be processed) and that the tile should be active. Then, each tick I'll increment the timer and only if 20 ticks (1 second) has passed since last time, I'll reset the timer and call a <code class="highlight"><span></span><span class="n">hurtMobs</span>
</pre></code> method (that I haven't defined yet). </p>
<pre><code class="highlight"><span></span><span class="kt">int</span> <span class="n">timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">boolean</span> <span class="n">isActive</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">tick</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="na">level</span><span class="p">.</span><span class="na">isClientSide</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="na">isActive</span><span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="na">timer</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">timer</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">){</span>
            <span class="k">this</span><span class="p">.</span><span class="na">timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">this</span><span class="p">.</span><span class="na">hurtMobs</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></code></pre>
<p>I'll start by deciding the top left and bottom right corner of the area I want to target. I'll do this by adding the my chosen range to all the coordinates of the tile entity to get the top and subtracting to get the bottom. Then I'll make an <code class="highlight"><span></span><span class="n">AxisAlignedBB</span>
</pre></code> from these points. This represents a cube centered on my tile entity going out <code class="highlight"><span></span><span class="n">RANGE</span>
</pre></code> blocks in all 3 dimensions. </p>
<p>Then I'll use the world's <code class="highlight"><span></span><span class="n">getEntities</span>
</pre></code> method to get all the entities within that area of effect. The first argument is an entity to ignore (arrows use this to not hit themselves) but I want to get everything so I'll leave it null. The second argument is obviously the <code class="highlight"><span></span><span class="n">AxisAlignedBB</span>
</pre></code> to get entities within. Then I'll loop through the list it returns. For each entity, I'll check that it is living (not an arrow, item, etc) and not a player (I don't want my new tile to hurt me!). If it meets my criteria, I'll deal one heart of magic damage. </p>
<pre><code class="highlight"><span></span><span class="kd">final</span> <span class="kt">int</span> <span class="n">RANGE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">hurtMobs</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">BlockPos</span> <span class="n">topCorner</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">worldPosition</span><span class="p">.</span><span class="na">offset</span><span class="p">(</span><span class="n">RANGE</span><span class="p">,</span> <span class="n">RANGE</span><span class="p">,</span> <span class="n">RANGE</span><span class="p">);</span>
    <span class="n">BlockPos</span> <span class="n">bottomCorner</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">worldPosition</span><span class="p">.</span><span class="na">offset</span><span class="p">(</span><span class="o">-</span><span class="n">RANGE</span><span class="p">,</span> <span class="o">-</span><span class="n">RANGE</span><span class="p">,</span> <span class="o">-</span><span class="n">RANGE</span><span class="p">);</span>
    <span class="n">AxisAlignedBB</span> <span class="n">box</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AxisAlignedBB</span><span class="p">(</span><span class="n">topCorner</span><span class="p">,</span> <span class="n">bottomCorner</span><span class="p">);</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">entities</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">level</span><span class="p">.</span><span class="na">getEntities</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="n">box</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Entity</span> <span class="n">target</span> <span class="p">:</span> <span class="n">entities</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="k">instanceof</span> <span class="n">LivingEntity</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">target</span> <span class="k">instanceof</span> <span class="n">PlayerEntity</span><span class="p">)){</span>
            <span class="n">target</span><span class="p">.</span><span class="na">hurt</span><span class="p">(</span><span class="n">DamageSource</span><span class="p">.</span><span class="na">MAGIC</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></code></pre>
<p>Note: instead of doing that check in the for loop, I could have passed in a <code class="highlight"><span></span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span>
</pre></code> which would return true only if it was something I want to target. That would probably run faster but not significantly enough to matter and I have a personal preference for how I did it. </p>
<h3>Processing Block Interactions</h3>
<p>I want to be able to toggle my mob slayer on and off by right clicking the block. I'll start by making a function that will preform the toggle. </p>
<pre><code class="highlight"><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">toggle</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="na">isActive</span> <span class="o">=</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="na">isActive</span><span class="p">;</span>
<span class="p">}</span>
</pre></code></pre>
<p>Then I need my block to notify my tile entity when it is right clicked. I'll override the <code class="highlight"><span></span><span class="n">use</span>
</pre></code> method as we did in the last tutorial. After checking that I'm on the server side and processing the main hand (so it doesn't get called twice), I'll get the tile entity at that position. To be safe, I'll check that it's the right type of tile entity but in practice it always will be. I'll cast it to my tile entity class and call the <code class="highlight"><span></span><span class="n">toggle</span>
</pre></code> method. For dramatic effect (and so its easier to tell that our click was processed), I'll make it play a sound as well. </p>
<pre><code class="highlight"><span></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">ActionResultType</span> <span class="nf">use</span><span class="p">(</span><span class="n">BlockState</span> <span class="n">state</span><span class="p">,</span> <span class="n">World</span> <span class="n">world</span><span class="p">,</span> <span class="n">BlockPos</span> <span class="n">pos</span><span class="p">,</span> <span class="n">PlayerEntity</span> <span class="n">player</span><span class="p">,</span> <span class="n">Hand</span> <span class="n">hand</span><span class="p">,</span> <span class="n">BlockRayTraceResult</span> <span class="n">hit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">world</span><span class="p">.</span><span class="na">isClientSide</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">hand</span> <span class="o">==</span> <span class="n">Hand</span><span class="p">.</span><span class="na">MAIN_HAND</span> <span class="p">){</span>
        <span class="n">TileEntity</span> <span class="n">tile</span> <span class="o">=</span> <span class="n">world</span><span class="p">.</span><span class="na">getBlockEntity</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tile</span> <span class="k">instanceof</span> <span class="n">MobSlayerTile</span><span class="p">){</span>
            <span class="p">((</span><span class="n">MobSlayerTile</span><span class="p">)</span> <span class="n">tile</span><span class="p">).</span><span class="na">toggle</span><span class="p">();</span>
            <span class="n">world</span><span class="p">.</span><span class="na">playSound</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">player</span><span class="p">.</span><span class="na">getX</span><span class="p">(),</span> <span class="n">player</span><span class="p">.</span><span class="na">getY</span><span class="p">(),</span> <span class="n">player</span><span class="p">.</span><span class="na">getZ</span><span class="p">(),</span> <span class="n">SoundEvents</span><span class="p">.</span><span class="na">ANVIL_LAND</span><span class="p">,</span> <span class="n">SoundCategory</span><span class="p">.</span><span class="na">PLAYERS</span><span class="p">,</span> <span class="mf">1.0F</span><span class="p">,</span> <span class="mf">1.0F</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">ActionResultType</span><span class="p">.</span><span class="na">SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kd">super</span><span class="p">.</span><span class="na">use</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">player</span><span class="p">,</span> <span class="n">hand</span><span class="p">,</span> <span class="n">hit</span><span class="p">);</span>
<span class="p">}</span>
</pre></code></pre>
<h3>NBT Data</h3>
<p>Currently, when I save the world and reload it, the <code class="highlight"><span></span><span class="n">isActive</span>
</pre></code> variable will default back to true. We can override a few methods to save it with the rest of the world's data. </p>
<p>The format Minecraft uses for most of the data it saves is called NBT (<a href="https://minecraft.fandom.com/wiki/NBT_format">Named Binary Tag</a>). This is basically a map of keys and values (just like a more limited version of a <code class="highlight"><span></span><span class="n">HashMap</span>
</pre></code>) that can easily be serialized to a binary representation to store in files. </p>
<p>In code, the class that is used for this format is <code class="highlight"><span></span><span class="n">CompoundNBT</span>
</pre></code>. There are many types of data you can store in an <code class="highlight"><span></span><span class="n">NBTCompound</span>
</pre></code>: <code class="highlight"><span></span><span class="kt">boolean</span>
</pre></code>, <code class="highlight"><span></span><span class="kt">int</span>
</pre></code>, <code class="highlight"><span></span><span class="n">String</span>
</pre></code>, <code class="highlight"><span></span><span class="kt">double</span>
</pre></code>, <code class="highlight"><span></span><span class="kt">float</span>
</pre></code>, <code class="highlight"><span></span><span class="kt">long</span>
</pre></code>, an array of <code class="highlight"><span></span><span class="kt">long</span>
</pre></code>s, <code class="highlight"><span></span><span class="kt">byte</span>
</pre></code>, an <code class="highlight"><span></span><span class="n">INBT</span>
</pre></code> (like another <code class="highlight"><span></span><span class="n">CompoundNBT</span>
</pre></code> or a <code class="highlight"><span></span><span class="n">ListNBT</span>
</pre></code>). You've got all the primitives and more so with enough effort you can make an nbt representation for any object. The general methods to use are <code class="highlight"><span></span><span class="n">compoundNBT</span><span class="p">.</span><span class="na">putType</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></code>, <code class="highlight"><span></span><span class="n">compoundNBT</span><span class="p">.</span><span class="na">getType</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></code> and <code class="highlight"><span></span><span class="n">compundNBT</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></code>. The key is always a <code class="highlight"><span></span><span class="n">String</span>
</pre></code> and the value can be any supported type (just change the method name, ie <code class="highlight"><span></span><span class="n">getString</span>
</pre></code>, etc).</p>
<p>Tile entities use the <code class="highlight"><span></span><span class="n">save</span>
</pre></code> method to get the data to store as a <code class="highlight"><span></span><span class="n">CompoundNBT</span>
</pre></code> when the world is saved and <code class="highlight"><span></span><span class="n">load</span>
</pre></code> to read back that nbt into normal variables. I'll use this to simply store my <code class="highlight"><span></span><span class="n">isActive</span>
</pre></code> field and read it back. Make sure to call the super methods to let Minecraft store the tile entity's base data. </p>
<pre><code class="highlight"><span></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">CompoundNBT</span> <span class="nf">save</span><span class="p">(</span><span class="n">CompoundNBT</span> <span class="n">nbt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">nbt</span><span class="p">.</span><span class="na">putBoolean</span><span class="p">(</span><span class="s">&quot;active&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="na">isActive</span><span class="p">);</span>
    <span class="k">return</span> <span class="kd">super</span><span class="p">.</span><span class="na">save</span><span class="p">(</span><span class="n">nbt</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">load</span><span class="p">(</span><span class="n">BlockState</span> <span class="n">state</span><span class="p">,</span> <span class="n">CompoundNBT</span> <span class="n">nbt</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">super</span><span class="p">.</span><span class="na">load</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">nbt</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="na">isActive</span> <span class="o">=</span> <span class="n">nbt</span><span class="p">.</span><span class="na">getBoolean</span><span class="p">(</span><span class="s">&quot;active&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></code></pre>
<p>Note that the nbt keys <code class="highlight"><span></span><span class="n">id</span>
</pre></code>, <code class="highlight"><span></span><span class="n">x</span>
</pre></code>, <code class="highlight"><span></span><span class="n">y</span>
</pre></code>, <code class="highlight"><span></span><span class="n">z</span>
</pre></code>, <code class="highlight"><span></span><span class="n">ForgeData</span>
</pre></code>, <code class="highlight"><span></span><span class="n">ForgeCaps</span>
</pre></code> and the registry name of the tile entity type (for me that's <code class="highlight"><span></span><span class="n">mob_slayer</span>
</pre></code>) are reserved for the default data Minecraft has to store about your tile entity. Do not try to use them. </p>
<h3>Syncing Data</h3>
<p>With my tile entity, I've been careful to do everything on the server side. If you're doing something more complex, you may have to sync data between the client and the server. There are a few ways to do this. I will cover examples where you need to use these in a later tutorial on doing custom rendering with a tile entity. <a href="https://discord.gg/VbZVnRd">Join the discord server</a> to be notified when it is released. </p>
<p><strong>On chunk load: </strong><code class="highlight"><span></span><span class="n">getUpdateTag</span><span class="p">()</span>
</pre></code> returns the data that the server wants to send as a <code class="highlight"><span></span><span class="n">CompoundNBT</span>
</pre></code>. <code class="highlight"><span></span><span class="n">handleUpdateTag</span><span class="p">(</span><span class="n">BlockState</span> <span class="n">state</span><span class="p">,</span> <span class="n">CompoundNBT</span> <span class="n">tag</span><span class="p">)</span>
</pre></code> reads it back on the client side.</p>
<p><strong>On block update:</strong> gotta use a packet! (but you can use one from vanilla). <code class="highlight"><span></span><span class="n">getUpdatePacket</span>
</pre></code> is sent from the server, <code class="highlight"><span></span><span class="n">onDataPacket</span>
</pre></code> is read on the client.</p>
<pre><code class="highlight"><span></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">SUpdateTileEntityPacket</span> <span class="nf">getUpdatePacket</span><span class="p">(){</span>
    <span class="n">CompoundNBT</span> <span class="n">nbtTag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompoundNBT</span><span class="p">();</span>
    <span class="c1">// save data to nbt </span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">SUpdateTileEntityPacket</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">worldPosition</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbtTag</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDataPacket</span><span class="p">(</span><span class="n">NetworkManager</span> <span class="n">net</span><span class="p">,</span> <span class="n">SUpdateTileEntityPacket</span> <span class="n">pkt</span><span class="p">){</span>
    <span class="n">CompoundNBT</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">pkt</span><span class="p">.</span><span class="na">getNbtCompound</span><span class="p">();</span>
    <span class="c1">// read data</span>
<span class="p">}</span>
</pre></code></pre>
<p>To trigger that you can call <code class="highlight"><span></span><span class="n">world</span><span class="p">.</span><span class="na">notifyBlockUpdate</span><span class="p">(</span><span class="n">BlockPos</span> <span class="n">pos</span><span class="p">,</span> <span class="n">BlockState</span> <span class="n">oldState</span><span class="p">,</span> <span class="n">BlockState</span> <span class="n">newState</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</pre></code></p>
<p><strong>Custom packet:</strong> a more versatile solution would be to make your own packets that you can send whenever you want (not just for block updates). I will cover packets in a future tutorial. <a href="https://discord.gg/VbZVnRd">Join the discord server</a> to be notified when it is released. </p>
<h2>Assets</h2>
<p>The block to which you bound your tile entity is a block like any other. Don't forget to give it a block model, item model, block state definition, loot table and lang entry.</p>
<h2>Extension</h2>
<ul>
<li>Make the mob slayer we made in this tutorial directional. That is, instead of the area of effect being centered on the block, have the block rotateable from like the last tutorial and only attack mobs in the forwards direction.</li>
<li>
<p>Make a tile entity that teleports nearby mobs on top of it</p>
<ul>
<li>hint: <code class="highlight"><span></span><span class="n">entity</span><span class="p">.</span><span class="na">setPos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</pre></code></li>
</ul>
</li>
</ul> 
        </div>

        <div class="hide-for-print">
            <br>
            <div class="hide-for-print centered">
                <a id="back-a" class="img-link">
                    <button class="btn btn-primary" style="width: 18%;" id="back">Back</button>
                </a>
                <a id="next-a" class="img-link">
                    <button class="btn btn-primary" style="width: 80%;" id="next">Next Tutorial</button>
                </a>
            </div>
            <br><br>
    
            <!--
    
            If you have any questions or suggestions, don't hesitate to ask me on [discord](https://discord.gg/VbZVnRd).
    
            Also, the full code for all my tutorials is available on [github](https://github.com/LukeGrahamLandry/forge-modding-tutorial/tree/1.16.5).
    
             -->

             <div style="border: 2px solid red; width: fit-content; display: inline-block;">
                <a href="https://github.com/LukeGrahamLandry/forge-modding-tutorial/tree/1.16.5" class="img-link">
                    <div class="app">
                        <img src="./img/github.png" style="width: 70px">
                    </div>
                </a>
        
                <a href="https://discord.gg/VbZVnRd" class="img-link">
                    <div class="app">
                        <img src="./img/discord.png" style="width: 70px">
                    </div>
                </a>
        
                <!--
                <a href="https://www.youtube.com/playlist?list=PLxBLp3RqmUMEU5vrtMY6tgfP2lnJD0OUj" class="img-link">
                    <div class="app">
                        <img src="img/youtube.png" style="width: 70px">
                    </div>
                </a>
                -->
        
                <a href="https://www.patreon.com/LukeGrahamLandry" class="img-link">
                    <div class="app">
                        <img src="./img/patreon.png" style="width: 70px">
                    </div>
                </a>    
             </div>
    
            <br> <br>
            <div id="nav" class="centered"></div>
        </div>
    

    <script src="/js/dark.js"></script>
    <script src="/index.js"></script>
    <script>
        let thisPage = window.location.pathname.split("/")[1].split(".")[0]
        let index = getTutorials().indexOf(thisPage);
        if (index == 0){
            document.getElementById("back").disabled = true;
        } else {
            document.getElementById("back-a").href = "/" + getTutorials()[index - 1];
        }

        if (index == (getTutorials().length - 1)){
            document.getElementById("next").disabled = true;
        } else {
            document.getElementById("next-a").href =  "/" + getTutorials()[index + 1]
        }
    </script>
</body>
</html>